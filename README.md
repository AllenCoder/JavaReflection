**反射代码测试**





1. Java 中的反射是非常规编码方式。
2. Java 反射机制的操作入口是获取 Class 文件。 有 Class.forName()、 .class 和 Object.getClass() 3 种。
3. 获取 Class 对象后还不够，需要获取它的 Members，包含 Field、Method、Constructor。
4. Field 操作主要涉及到类别的获取，及数值的读取与赋值。
5. Method 算是反射机制最核心的内容，通常的反射都是为了调用某个 Method 的 invoke() 方法。
6. 通过 Class.newInstance() 和 Constructor.newInstance() 都可以创建类的对象实例，但推荐后者。因为它适应于任何构造方法，而前者只会调用可见的无参数的构造方法。
7. 数组和枚举可以被看成普通的 Class 对待。
8. 反射能调用私有属性和私有方法
9. 反射能修复私有字段值
10. 反射不能修改私有方法的运行逻辑一般是通过新方法替换掉原来老方法的私有逻辑达到修复效果（公有方法不在此讨论范围）

## 反射是非常规开发手段，它会抛弃 Java 虚拟机的很多优化，所以同样功能的代码，反射要比正常方式要慢，所以考虑到采用反射时，要考虑它的时间成本。另外，就如无人驾驶之于汽车一样，用着很爽的同时，其实风险未知。


缺点

性能问题：通过反射访问、修改类的属性和方法时会远慢于直接操作，但性能问题的严重程度取决于在程序中是如何使用反射的。如果使用得很少，不是很频繁，性能将不会是什么问题；

安全性问题：反射可以随意访问和修改类的所有状态和行为，破坏了类的封装性，如果不熟悉被反射类的实现原理，随意修改可能导致潜在的逻辑问题；

兼容性问题：因为反射会涉及到直接访问类的方法名和实例名，不同版本的API如果有变动，反射时找不到对应的属性和方法时会报异常；

说明

通过反射访问方法比实例慢很多；

有用到反射的类不能被混淆；

反射存在性能问题，但使用不频繁、按需使用时，对程序性能影响并不大；

反射存在安全性问题，因为可以随意修改类的所有状态和行为（包括private方法和实例）；

使用反射访问Android的API时需要注意因为不同API版本导致的兼容性问题；

